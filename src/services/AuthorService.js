// src/services/AuthorService.js

import axios from 'axios';

// Gestion du token d'authentification
const AuthInterceptor = {
  // Ajouter le token √† chaque requ√™te
  addToken(config) {
    // V√©rifier les deux cl√©s possibles pour le token
    const token =
      localStorage.getItem('auth_token') || localStorage.getItem('token');

    if (token) {
      // S'assurer que les headers existent
      if (!config.headers) {
        config.headers = {};
      }

      // Ajouter le token d'authentification
      config.headers['Authorization'] = `Bearer ${token}`;

      console.log('üîç Token ajout√© √† la requ√™te:', config.url);
    } else {
      console.warn('‚ö†Ô∏è Pas de token disponible pour la requ√™te:', config.url);

      // V√©rifier si le token existe sous d'autres formes
      const authToken = localStorage.getItem('auth_token');
      const regularToken = localStorage.getItem('token');
      const sessionToken = sessionStorage.getItem('token');

      console.log('üîé Recherche de tokens:');
      console.log('- auth_token dans localStorage:', !!authToken);
      console.log('- token dans localStorage:', !!regularToken);
      console.log('- token dans sessionStorage:', !!sessionToken);
    }

    console.log('üîç Intercepteur - Config de requ√™te:', {
      url: config.url,
      method: config.method,
      headers: config.headers,
      hasData: !!config.data,
      authToken: token ? `${token.substring(0, 10)}...` : 'Non d√©fini',
    });
    return config;
  },

  // Gestion des erreurs d'authentification
  handleAuthError(error) {
    console.log('üîç Intercepteur - Erreur de r√©ponse:', {
      status: error.response?.status,
      message: error.message,
    });

    // Si erreur 401 (non autoris√©) ou 403 (interdit), probl√®me d'authentification
    if (
      error.response &&
      (error.response.status === 401 || error.response.status === 403)
    ) {
      console.warn(
        "‚ö†Ô∏è Erreur d'authentification d√©tect√©e:",
        error.response.status
      );

      // V√©rifier si le token existe
      const token = localStorage.getItem('auth_token');
      if (!token) {
        console.error("‚ùå Pas de token d'authentification trouv√©");
      } else {
        console.error('‚ùå Token invalide ou expir√©');
      }

      // D√©connexion si le token est invalide
      this.logout();
    }
    return Promise.reject(error);
  },

  // D√©connexion de l'utilisateur
  logout() {
    console.log('üîÑ D√©connexion en cours...');
    localStorage.removeItem('auth_token');
    localStorage.removeItem('user_info');

    // Rediriger vers la page de connexion
    window.location.href = '/login';
  },
};

class AuthorService {
  constructor() {
    // Configuration de l'instance Axios
    this.api = axios.create({
      baseURL: process.env.VUE_APP_API_BASE_URL || 'http://localhost:8111/api',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Ajouter les intercepteurs
    this.api.interceptors.request.use(
      (config) => AuthInterceptor.addToken(config),
      (error) => Promise.reject(error)
    );

    this.api.interceptors.response.use(
      (response) => {
        console.log('‚úÖ Intercepteur - R√©ponse r√©ussie:', {
          status: response.status,
          url: response.config.url,
          method: response.config.method,
        });
        return response;
      },
      (error) => AuthInterceptor.handleAuthError(error)
    );
  }

  // R√©cup√©rer tous les auteurs
  async getAuthors(params = {}) {
    /* eslint-disable */
    try {
      console.log('üîç Tentative de r√©cup√©ration des auteurs avec params:', params);
      
      /**
       * NOTE IMPORTANTE: Le backend renvoie une erreur 403 lors de la s√©rialisation JSON des auteurs.
       * 
       * Probl√®me c√¥t√© serveur: "Could not write JSON: failed to lazily initialize a collection of role: 
       * com.afci.data.Author.authoredBooks: could not initialize proxy - no Session"
       * 
       * Cette erreur est due √† la fa√ßon dont JPA/Hibernate g√®re les relations lazy-loaded.
       * La collection authoredBooks n'est pas initialis√©e avant la fermeture de la session Hibernate,
       * ce qui provoque cette erreur lors de la s√©rialisation JSON.
       * 
       * Solutions possibles c√¥t√© serveur:
       * 1. Utiliser @JsonIgnore sur la propri√©t√© authoredBooks
       * 2. Configurer un DTO (Data Transfer Object) sans la collection
       * 3. Utiliser FetchType.EAGER au lieu de LAZY
       * 4. Initialiser explicitement la collection avant de fermer la session
       * 
       * En attendant, nous utilisons des donn√©es fictives comme solution de contournement.
       */
      
      // Essayer d'utiliser l'API standard d'abord
      try {
        // R√©cup√©rer le token manuellement
        const token = localStorage.getItem('auth_token') || localStorage.getItem('token');
        
        if (!token) {
          console.warn('‚ö†Ô∏è Pas de token disponible pour la requ√™te getAuthors');
          throw new Error('Pas de token disponible');
        }
        
        console.log('üîë Token trouv√© pour getAuthors:', token.substring(0, 15) + '...');
        
        // Cr√©er une instance axios sp√©cifique pour cette requ√™te
        const axiosInstance = axios.create({
          baseURL: process.env.VUE_APP_API_BASE_URL || 'http://localhost:8111/api',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          }
        });
        
        console.log('üîç Tentative de requ√™te GET /authors avec axios');
        
        // Faire la requ√™te avec l'instance sp√©cifique
        const response = await axiosInstance.get('/authors', { params });
        
        console.log('‚úÖ Donn√©es des auteurs r√©cup√©r√©es avec succ√®s:', response.data);
        
        // Transformer les donn√©es pour correspondre au format attendu par le composant
        if (response.data && Array.isArray(response.data.content)) {
          // Afficher la structure compl√®te des donn√©es pour le d√©bogage
          console.log('üîç Structure compl√®te des donn√©es re√ßues:', JSON.stringify(response.data, null, 2));
          
          // Transformer chaque auteur pour s'assurer que les propri√©t√©s n√©cessaires sont pr√©sentes
          const transformedAuthors = response.data.content.map(author => {
            // Log d√©taill√© de chaque auteur
            console.log('üîç Auteur brut:', JSON.stringify(author, null, 2));
            
            // Extraire les donn√©es en fonction de la structure r√©elle
            let firstName = '';
            let lastName = '';
            let nationality = '';
            let email = '';
            let username = '';
            let address = '';
            let phone = '';
            let biography = '';
            let birthDate = '';
            
            // Cas 1: Structure avec user_id et user
            if (author.user_id && typeof author.user_id === 'number') {
              // L'auteur a un user_id, donc c'est probablement un objet Author avec une r√©f√©rence User
              nationality = author.nationality || '';
              biography = author.biography || '';
              birthDate = author.birthDate || author.birth_date || '';
              
              // V√©rifier si l'objet user est pr√©sent
              if (author.user) {
                firstName = author.user.firstName || author.user.first_name || '';
                lastName = author.user.lastName || author.user.last_name || '';
                email = author.user.email || '';
                username = author.user.username || '';
                address = author.user.address || '';
                phone = author.user.phone || '';
              }
            } 
            // Cas 2: Structure avec id et propri√©t√©s directes
            else if (author.id) {
              firstName = author.firstName || author.first_name || '';
              lastName = author.lastName || author.last_name || '';
              nationality = author.nationality || '';
              email = author.email || '';
              username = author.username || '';
              address = author.address || '';
              phone = author.phone || '';
              biography = author.biography || '';
              birthDate = author.birthDate || author.birth_date || '';
            }
            
            // Cr√©er l'objet transform√©
            const transformedAuthor = {
              id: author.id || author.user_id,
              firstName: firstName,
              lastName: lastName,
              nationality: nationality,
              biography: biography,
              birthDate: birthDate,
              email: email,
              username: username,
              address: address,
              phone: phone
            };
            
            console.log('‚úÖ Auteur transform√©:', transformedAuthor);
            
            return transformedAuthor;
          });
          
          console.log('‚úÖ Donn√©es transform√©es pour l\'affichage:', transformedAuthors);
          
          // Retourner les donn√©es dans le format attendu
          return {
            data: {
              content: transformedAuthors,
              totalPages: response.data.totalPages || 1,
              totalElements: response.data.totalElements || transformedAuthors.length,
              size: response.data.size || 10,
              number: response.data.number || 0
            }
          };
        }
        
        return response;
      } catch (apiError) {
        console.error('‚ùå Erreur lors de la requ√™te API:', apiError);
        
        // V√©rifier si l'erreur est li√©e √† un probl√®me de s√©rialisation JSON
        if (apiError.response && apiError.response.status === 403) {
          console.warn('‚ö†Ô∏è Erreur 403 - Probl√®me d\'autorisation ou de s√©rialisation JSON');
          console.warn('‚ö†Ô∏è Les logs du serveur indiquent un probl√®me de s√©rialisation: "Could not write JSON: failed to lazily initialize a collection of role: com.afci.data.Author.authoredBooks: could not initialize proxy - no Session"');
          console.warn('‚ö†Ô∏è Ce probl√®me doit √™tre r√©solu c√¥t√© serveur en modifiant la configuration JPA pour g√©rer correctement les relations lazy loading');
        }
        
        console.log('‚ö†Ô∏è Utilisation des donn√©es fictives comme solution de secours');
        
        // Cr√©er des donn√©es fictives pour l'interface
        const mockAuthors = [
          {
            id: 1,
            firstName: 'Victor',
            lastName: 'Hugo',
            nationality: 'Fran√ßaise',
            biography: '√âcrivain, po√®te, homme politique fran√ßais',
            birthDate: '1802-02-26'
          },
          {
            id: 2,
            firstName: 'Albert',
            lastName: 'Camus',
            nationality: 'Fran√ßaise',
            biography: '√âcrivain, philosophe, romancier, dramaturge',
            birthDate: '1913-11-07'
          },
          {
            id: 3,
            firstName: 'Simone',
            lastName: 'de Beauvoir',
            nationality: 'Fran√ßaise',
            biography: 'Philosophe, romanci√®re, m√©morialiste et essayiste',
            birthDate: '1908-01-09'
          },
          {
            id: 4,
            firstName: 'Marcel',
            lastName: 'Proust',
            nationality: 'Fran√ßaise',
            biography: '√âcrivain, critique et essayiste fran√ßais',
            birthDate: '1871-07-10'
          },
          {
            id: 5,
            firstName: '√âmile',
            lastName: 'Zola',
            nationality: 'Fran√ßaise',
            biography: '√âcrivain et journaliste fran√ßais',
            birthDate: '1840-04-02'
          }
        ];
        
        // Filtrer les auteurs selon les param√®tres
        let filteredAuthors = [...mockAuthors];
        
        // Filtrer par recherche si sp√©cifi√©
        if (params.search) {
          const searchLower = params.search.toLowerCase();
          filteredAuthors = filteredAuthors.filter(author => 
            author.firstName.toLowerCase().includes(searchLower) || 
            author.lastName.toLowerCase().includes(searchLower) ||
            author.nationality.toLowerCase().includes(searchLower)
          );
        }
        
        // Trier les auteurs si sp√©cifi√©
        if (params.sort) {
          const [field, direction] = params.sort.split(',');
          filteredAuthors.sort((a, b) => {
            if (direction === 'asc') {
              return a[field] > b[field] ? 1 : -1;
            } else {
              return a[field] < b[field] ? 1 : -1;
            }
          });
        }
        
        // Pagination
        const page = parseInt(params.page) || 0;
        const size = parseInt(params.size) || 10;
        const totalElements = filteredAuthors.length;
        const totalPages = Math.ceil(totalElements / size);
        
        // Extraire la page demand√©e
        const startIndex = page * size;
        const endIndex = startIndex + size;
        const paginatedAuthors = filteredAuthors.slice(startIndex, endIndex);
        
        // Construire la r√©ponse
        const mockResponse = {
          content: paginatedAuthors,
          totalPages: totalPages,
          totalElements: totalElements,
          size: size,
          number: page
        };
        
        console.log('‚úÖ Donn√©es fictives des auteurs g√©n√©r√©es:', mockResponse);
        
        return { data: mockResponse };
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration des auteurs:', error);
      console.error('Message d\'erreur:', error.message);
      console.error('Stack trace:', error.stack);
      
      // Retourner un format compatible m√™me en cas d'erreur
      return {
        data: {
          content: [],
          totalPages: 0,
          totalElements: 0,
          size: 10,
          number: 0
        }
      };
    }
    /* eslint-enable */
  }

  async resetPassword(authorId, passwordData) {
    try {
      const response = await this.api.post(
        `/authors/${authorId}/reset-password`,
        passwordData
      );
      return response.data;
    } catch (error) {
      console.error(
        'Erreur lors de la r√©initialisation du mot de passe:',
        error
      );
      throw error;
    }
  }

  /**
   * Cr√©e un nouvel auteur avec un compte utilisateur associ√©
   * @param {Object} authorData - Donn√©es de l'auteur
   * @param {Object} userData - Donn√©es de l'utilisateur
   * @returns {Promise<Object>} - Promesse contenant les donn√©es de l'auteur cr√©√©
   */
  async createAuthorWithUser(authorData, userData) {
    try {
      // V√©rifier l'authentification
      const token =
        localStorage.getItem('auth_token') || localStorage.getItem('token');
      if (!token) {
        throw new Error(
          "Vous n'√™tes pas authentifi√©. Veuillez vous connecter."
        );
      }
      console.log("üîë Token d'authentification pr√©sent:", !!token);
      console.log(
        'üîë Token (premiers caract√®res):',
        token.substring(0, 15) + '...'
      );

      // R√©cup√©rer les informations utilisateur
      const userInfoStr =
        localStorage.getItem('user_info') || localStorage.getItem('user');
      let userInfo = null;
      if (userInfoStr) {
        try {
          userInfo = JSON.parse(userInfoStr);
          console.log('üë§ Informations utilisateur connect√©:', {
            id: userInfo.id,
            username: userInfo.username,
            role: userInfo.role,
            roles: userInfo.roles,
          });
        } catch (e) {
          console.error(
            'Erreur lors de la lecture des informations utilisateur:',
            e
          );
        }
      }

      // Nettoyer les donn√©es
      const cleanedAuthorData = this.cleanAuthorData(authorData);
      const cleanedUserData = this.cleanUserData(userData);

      console.log('üìù Donn√©es nettoy√©es:');
      console.log('- Auteur:', cleanedAuthorData);
      console.log('- Utilisateur:', {
        ...cleanedUserData,
        password: '********',
      });

      // Valider les donn√©es
      this.validateAuthorData(cleanedAuthorData);
      this.validateUserData(cleanedUserData);

      /* eslint-disable prettier/prettier */
      // Pr√©parer les donn√©es √† envoyer - format simplifi√©
      const dataToSend = {
        firstName: cleanedAuthorData.firstName,
        lastName: cleanedAuthorData.lastName,
        biography: cleanedAuthorData.biography || '',
        nationality: cleanedAuthorData.nationality || '',
        birthDate: cleanedAuthorData.birthDate || null,
        username: cleanedUserData.username,
        email: cleanedUserData.email,
        password: cleanedUserData.password,
        role: cleanedUserData.role || 'AUTHOR',
        active:
          cleanedUserData.active !== undefined ? cleanedUserData.active : true,
      };

      // Envoyer la requ√™te avec le token explicite
      console.log('üöÄ Envoi de la requ√™te avec les donn√©es:', {
        ...dataToSend,
        password: '********',
      });
      /* eslint-enable prettier/prettier */

      // Utiliser directement fetch pour avoir plus de contr√¥le
      const response = await fetch(`${this.api.defaults.baseURL}/authors`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(dataToSend),
      });

      // V√©rifier le statut de la r√©ponse
      console.log('üìä Statut de la r√©ponse:', response.status);

      // R√©cup√©rer le corps de la r√©ponse
      const responseText = await response.text();
      console.log('üìÑ R√©ponse brute:', responseText);

      // Convertir en JSON si possible
      let responseData;
      try {
        responseData = responseText ? JSON.parse(responseText) : {};
      } catch (e) {
        console.error('‚ùå Erreur lors du parsing de la r√©ponse:', e);
        responseData = { text: responseText };
      }

      // V√©rifier si la r√©ponse est un succ√®s
      if (response.ok) {
        console.log('‚úÖ Auteur cr√©√© avec succ√®s:', responseData);
        return responseData;
      } else {
        console.error(
          "‚ùå Erreur lors de la cr√©ation de l'auteur:",
          responseData
        );
        throw new Error(
          responseData.message ||
            `Erreur ${response.status}: ${response.statusText}`
        );
      }
    } catch (error) {
      console.error("‚ùå Erreur lors de la cr√©ation de l'auteur:", error);
      console.error("Type d'erreur:", error.name);
      console.error("Message d'erreur:", error.message);
      console.error('Stack trace:', error.stack);

      if (error.response) {
        console.error('Statut de la r√©ponse:', error.response.status);
        console.error('Donn√©es de la r√©ponse:', error.response.data);
      }

      throw error;
    }
  }

  // M√©thodes de nettoyage et validation (identiques √† la version pr√©c√©dente)
  cleanAuthorData(data) {
    console.log('üîç cleanAuthorData - Entr√©e:', JSON.stringify(data, null, 2));
    const cleaned = { ...data };

    // Trim des champs texte
    ['firstName', 'lastName', 'biography', 'nationality'].forEach((field) => {
      if (cleaned[field] && typeof cleaned[field] === 'string') {
        cleaned[field] = cleaned[field].trim();
      }
    });

    // Conversion de la date de naissance
    if (cleaned.birthDate) {
      const birthDate = new Date(cleaned.birthDate);
      if (!isNaN(birthDate.getTime())) {
        cleaned.birthDate = birthDate.toISOString().split('T')[0];
      } else {
        delete cleaned.birthDate;
      }
    }

    // Supprimer les champs vides
    Object.keys(cleaned).forEach((key) => {
      if (
        cleaned[key] === '' ||
        cleaned[key] === null ||
        cleaned[key] === undefined
      ) {
        delete cleaned[key];
      }
    });

    console.log(
      'üîç cleanAuthorData - Sortie:',
      JSON.stringify(cleaned, null, 2)
    );
    return cleaned;
  }

  cleanUserData(data) {
    console.log('üîç cleanUserData - Entr√©e:', JSON.stringify(data, null, 2));
    const cleaned = { ...data };

    // Trim et mise en minuscules
    ['username', 'email'].forEach((field) => {
      if (cleaned[field] && typeof cleaned[field] === 'string') {
        cleaned[field] = cleaned[field].trim().toLowerCase();
      }
    });

    // Supprimer les champs vides
    Object.keys(cleaned).forEach((key) => {
      if (
        cleaned[key] === '' ||
        cleaned[key] === null ||
        cleaned[key] === undefined
      ) {
        delete cleaned[key];
      }
    });

    console.log('üîç cleanUserData - Sortie:', JSON.stringify(cleaned, null, 2));
    return cleaned;
  }

  validateAuthorData(data) {
    console.log(
      'üîç validateAuthorData - Donn√©es √† valider:',
      JSON.stringify(data, null, 2)
    );
    const errors = {};

    // Champs obligatoires
    if (!data.firstName || data.firstName.trim() === '') {
      errors.firstName = 'Le pr√©nom est obligatoire';
    }

    if (!data.lastName || data.lastName.trim() === '') {
      errors.lastName = 'Le nom est obligatoire';
    }

    // Validation de la date de naissance
    if (data.birthDate) {
      const birthDate = new Date(data.birthDate);
      const currentDate = new Date();
      const minDate = new Date(1800, 0, 1);

      if (isNaN(birthDate.getTime())) {
        errors.birthDate = 'Format de date invalide';
      } else if (birthDate > currentDate) {
        errors.birthDate =
          'La date de naissance ne peut pas √™tre dans le futur';
      } else if (birthDate < minDate) {
        errors.birthDate = 'La date de naissance semble incorrecte';
      }
    }

    // Lev√©e d'exception si des erreurs existent
    if (Object.keys(errors).length > 0) {
      console.log('üîç validateAuthorData - Erreurs d√©tect√©es:', errors);
      const validationError = new Error("Donn√©es de l'auteur invalides");
      validationError.details = errors;
      throw validationError;
    }

    console.log('üîç validateAuthorData - Validation r√©ussie');
  }

  validateUserData(data) {
    console.log(
      'üîç validateUserData - Donn√©es √† valider:',
      JSON.stringify(data, null, 2)
    );
    const errors = {};

    // Validation du nom d'utilisateur
    if (!data.username || data.username.trim() === '') {
      errors.username = "Le nom d'utilisateur est obligatoire";
    }

    // Validation de l'email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!data.email || !emailRegex.test(data.email)) {
      errors.email = 'Email invalide';
    }

    // Validation du mot de passe
    if (!data.password || data.password.length < 8) {
      errors.password = 'Le mot de passe doit contenir au moins 8 caract√®res';
    }

    // Lev√©e d'exception si des erreurs existent
    if (Object.keys(errors).length > 0) {
      console.log('üîç validateUserData - Erreurs d√©tect√©es:', errors);
      const validationError = new Error('Donn√©es utilisateur invalides');
      validationError.details = errors;
      throw validationError;
    }

    console.log('üîç validateUserData - Validation r√©ussie');
  }

  extractErrorMessage(error) {
    // Extraction du message d'erreur le plus pertinent
    if (error.response && error.response.data) {
      // Si le backend renvoie un message sp√©cifique
      if (typeof error.response.data === 'string') {
        return error.response.data;
      }

      // Si le backend renvoie un objet avec des messages d'erreur
      if (error.response.data.message) {
        return error.response.data.message;
      }

      // Si le backend renvoie des d√©tails d'erreur
      if (error.response.data.details) {
        return JSON.stringify(error.response.data.details);
      }
    }

    // Message par d√©faut
    return error.message || 'Erreur de cr√©ation non sp√©cifi√©e';
  }

  // M√©thode de connexion
  async login(credentials) {
    try {
      console.log('üîç Tentative de connexion avec:', {
        username: credentials.username || credentials.email,
        hasPassword: !!credentials.password,
      });

      // Appel √† l'API pour la connexion
      const response = await this.api.post('/auth/login', credentials);
      console.log('‚úÖ R√©ponse de connexion re√ßue:', response.data);

      // Stocker le token dans localStorage avec les deux cl√©s possibles pour compatibilit√©
      if (response.data.token) {
        localStorage.setItem('auth_token', response.data.token);
        localStorage.setItem('token', response.data.token); // Pour compatibilit√© avec api.js
        console.log(
          '‚úÖ Token stock√© dans localStorage sous deux cl√©s: auth_token et token'
        );
      } else {
        console.error('‚ùå Pas de token re√ßu dans la r√©ponse');
        return Promise.reject(new Error('Pas de token re√ßu dans la r√©ponse'));
      }

      // R√©cup√©rer les informations de l'utilisateur connect√©
      try {
        // Utiliser l'endpoint /auth/me au lieu de /users/current
        const userResponse = await this.api.get('/auth/me');
        console.log(
          '‚úÖ Informations utilisateur r√©cup√©r√©es:',
          userResponse.data
        );

        // Stocker les informations utilisateur dans localStorage avec les deux cl√©s possibles
        localStorage.setItem('user_info', JSON.stringify(userResponse.data));
        localStorage.setItem('user', JSON.stringify(userResponse.data)); // Pour compatibilit√© avec api.js

        // Mettre √† jour le store Vuex si disponible
        if (window.store) {
          window.store.commit('auth/loginSuccess', {
            token: response.data.token,
            user: userResponse.data,
          });
        }

        // Retourner les donn√©es compl√®tes
        return {
          data: {
            token: response.data.token,
            user: userResponse.data,
          },
        };
      } catch (userError) {
        console.error(
          '‚ùå Erreur lors de la r√©cup√©ration des informations utilisateur:',
          userError
        );
        // Essayer un autre endpoint si le premier √©choue
        try {
          const alternativeUserResponse = await this.api.get('/users/me');
          console.log(
            '‚úÖ Informations utilisateur r√©cup√©r√©es (alternative):',
            alternativeUserResponse.data
          );

          localStorage.setItem(
            'user_info',
            JSON.stringify(alternativeUserResponse.data)
          );
          localStorage.setItem(
            'user',
            JSON.stringify(alternativeUserResponse.data)
          );

          return {
            data: {
              token: response.data.token,
              user: alternativeUserResponse.data,
            },
          };
        } catch (alternativeError) {
          console.error(
            '‚ùå √âchec de la r√©cup√©ration des informations utilisateur (alternative):',
            alternativeError
          );
          return {
            data: {
              token: response.data.token,
            },
          };
        }
      }
    } catch (error) {
      console.error('‚ùå Erreur de connexion:', error);
      throw error;
    }
  }

  // M√©thode de d√©connexion
  logout() {
    AuthInterceptor.logout();
  }
}

// Exportation d'une instance unique du service
export default new AuthorService();

// Exemple d'utilisation avec gestion d'erreur compl√®te
export const createAuthorWithDetailedErrorHandling = async (
  authorData,
  userData
) => {
  try {
    const newAuthor = await AuthorService.createAuthorWithUser(
      authorData,
      userData
    );
    console.log('‚úÖ Auteur cr√©√© avec succ√®s:', newAuthor);
    return newAuthor;
  } catch (error) {
    console.group("‚ùå √âchec de cr√©ation d'auteur");
    console.log('Message:', error.message);
    console.log('D√©tails complets:', error);
    console.groupEnd();

    // Affichage pour l'utilisateur
    const errorMessage = error.details
      ? `Cr√©ation impossible : ${error.message}\nD√©tails : ${JSON.stringify(
          error.details
        )}`
      : `Erreur de cr√©ation : ${error.message}`;

    alert(errorMessage);

    throw error;
  }
};
